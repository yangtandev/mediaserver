const HTTP = require('http');
const FS = require('fs');
const SPAWN = require('child_process').spawn;
const EXPRESS = require('express');
const CORS = require('cors');
const APP = EXPRESS();
const SERVER = HTTP.createServer(APP);
const PORT = 3000;
const PM2_PATH = process.env.NVM_BIN + '/pm2';
const BACKUP_PATH = `./ZLMediaKit/release/linux/Debug/www`;
const CONFIG_PATH = `./ZLMediaKit/release/linux/Debug/www/config/config.json`;
const FFMPEG = require('fluent-ffmpeg');
FFMPEG.setFfmpegPath(`./ffmpeg/ffmpeg`);
const RTSP_COMMANDS = {};
const MP4_COMMANDS = {};
let CONFIG = {};
let CONVERT_LIVE_STREAM_TO_MP4 = false;

/*
    Convert the original RTSP stream to a format acceptable to Media Server.
*/
function RTSPToRTSP(rtsp, type) {
	const ip = rtsp.split('@').pop().split('/').shift();
	const id = ip.match(/\d+/g).join('');
	const output = `rtsp://localhost:9554/live/${ip}`;

	if (RTSP_COMMANDS.hasOwnProperty(id)) {
		console.log(
			`[INFO] RTSP-to-RTSP conversion for ${id} is already running.`
		);
		return;
	}

	const command = FFMPEG(rtsp)
		.addInputOption(
			'-rtsp_transport',
			'tcp',
			'-re',
			'-hwaccel',
			'cuda',
			'-hwaccel_output_format',
			'cuda',
			'-c:v',
			`${type}_cuvid`
		)
		.addOutputOption(
			'-rtsp_transport',
			'tcp',
			'-preset',
			'medium',
			'-movflags',
			'faststart',
			'-threads',
			2
		)
		.output(output)
		.outputFormat('rtsp')
		.videoCodec('h264_nvenc')
		.noAudio()
		.on('start', function (cmd) {
			console.log(`[INFO] Started RTSP-to-RTSP for ${id}: ${cmd}`);
		})
		.on('end', function () {
			console.log(
				`[INFO] RTSP-to-RTSP process for ${id} finished successfully.`
			);
			delete RTSP_COMMANDS[id];
		})
		.on('error', function (err, stdout, stderr) {
			console.error(
				`[ERROR] RTSP-to-RTSP process for ${id} failed:`,
				err.message
			);
			delete RTSP_COMMANDS[id];

			// Automatically restart after a delay
			setTimeout(() => {
				console.log(
					`[INFO] Retrying RTSP-to-RTSP conversion for ${rtsp}...`
				);
				RTSPToRTSP(rtsp, type);
			}, 5000);
		});

	RTSP_COMMANDS[id] = command;
	command.run();
}

/*
    Capture the MP4 stream generated by the Media Server and store it in the specified location.
*/
function RTSPToMP4(rtsp) {
	const ip = rtsp.includes('@')
		? rtsp.split('@').pop().split('/').shift()
		: rtsp.split('/').pop();

	const id = ip.includes(':') ? ip.match(/\d+/g).join('') : ip;
	const clientInfo = CONFIG.clientList.find((client) => {
		if (client.rtspList) {
			return client.rtspList.includes(rtsp);
		}
	});

	if (!clientInfo) {
		console.error(`[ERROR] Could not find client info for RTSP: ${rtsp}`);
		return;
	}
	const { clientName } = clientInfo;

	const input = `rtsp://localhost:9554/live/${ip}`;
	const now = new Date(
		new Date().getTime() - new Date().getTimezoneOffset() * 60000 + 13000
	);
	const today = now.toISOString().replace(/\:+/g, '-').slice(0, 10);
	const fileName = now.toISOString().slice(0, -5).split('T').join(' ');
	let output_dir = BACKUP_PATH;

	for (let path of [clientName, 'backup', today, ip]) {
		output_dir += `/${path}`;
		if (!FS.existsSync(output_dir)) {
			FS.mkdirSync(output_dir, { recursive: true });
		}
	}

	const output_path = `${output_dir}/${fileName}.mp4`;

	if (MP4_COMMANDS.hasOwnProperty(id)) {
		console.log(
			`[INFO] RTSP-to-MP4 conversion for ${id} is already running.`
		);
		return;
	}

	const command = FFMPEG(input)
		.addInputOption(
			'-rtsp_transport',
			'tcp',
			'-use_wallclock_as_timestamps',
			1,
			'-ss',
			0,
			'-to',
			300 // 5 minutes
		)
		.addOutputOption(
			'-fps_mode',
			'passthrough',
			'-preset',
			'medium',
			'-movflags',
			'faststart',
			'-avoid_negative_ts',
			'make_zero',
			'-threads',
			2
		)
		.videoCodec('h264_nvenc')
		.noAudio()
		.on('start', function (cmd) {
			console.log(`[INFO] Started RTSP-to-MP4 for ${id}: ${cmd}`);
		})
		.on('end', function () {
			console.log(`[INFO] RTSP-to-MP4 clip for ${id} finished.`);
			delete MP4_COMMANDS[id]; // Clean up before restarting

			// Check for zero-byte file
			FS.stat(output_path, (error, stats) => {
				if (error) {
					console.error(
						`[ERROR] Could not stat output file ${output_path}:`,
						error
					);
				} else if (stats.isFile() && stats.size === 0) {
					console.log(
						`[INFO] Removing zero-byte file: ${output_path}`
					);
					FS.unlink(output_path, (err) => {
						if (err)
							console.error(
								`[ERROR] Failed to delete zero-byte file:`,
								err
							);
					});
				}
			});

			// Loop to record the next clip
			RTSPToMP4(rtsp);
		})
		.on('error', function (err, stdout, stderr) {
			console.error(
				`[ERROR] RTSP-to-MP4 process for ${id} failed:`,
				err.message
			);
			delete MP4_COMMANDS[id];

			// Automatically restart after a delay
			setTimeout(() => {
				console.log(
					`[INFO] Retrying RTSP-to-MP4 conversion for ${rtsp}...`
				);
				RTSPToMP4(rtsp);
			}, 5000);
		})
		.save(output_path);

	MP4_COMMANDS[id] = command;
}

/*
    Set rtsp list related variables.
*/
function setRtspList() {
	const source = JSON.parse(FS.readFileSync(CONFIG_PATH, 'utf8'));
	const typeList = ['rtmp', 'h264Rtsp', 'hevcRtsp'];
	CONFIG = JSON.parse(JSON.stringify(source));
	CONFIG[`clientList`] = [];

	typeList.forEach((type) => {
		CONFIG[`clientList`] = CONFIG[`clientList`].concat(
			CONFIG[`${type}ClientList`]
		);

		if (CONFIG[`${type}ClientList`].length > 0) {
			CONFIG[`${type}List`] = CONFIG[`${type}ClientList`]
				.map((client) => {
					if (client[`rtspList`]) return client[`rtspList`];
					if (client[`rtmpList`]) return client[`rtmpList`];
				})
				.reduce((prev, curr) => prev.concat(curr));
		} else {
			CONFIG[`${type}ClientList`] = [];
			CONFIG[`${type}List`] = [];
		}
	});

	CONFIG.allRtspList = []
		.concat(CONFIG.h264RtspList)
		.concat(CONFIG.hevcRtspList);
}

/*
    Periodically clear backups that are one month overdue.
*/
function clearExpiredBackup() {
	const clientList = CONFIG[`clientList`].map((client) => client.clientName);
	const expireLimitDays = 30;
	for (const client of clientList) {
		FS.readdir(`${BACKUP_PATH}/${client}/backup`, (err, dates) => {
			if (err) throw err;

			dates.forEach((date) => {
				const now = new Date(
					new Date().getTime() -
						new Date().getTimezoneOffset() * 60000
				);
				const currentDate = now
					.toISOString()
					.replace(/\:+/g, '-')
					.slice(0, 10);
				let dateDiff = parseInt(
					Math.abs(new Date(currentDate) - new Date(date)) /
						1000 /
						60 /
						60 /
						24
				);

				if (dateDiff > expireLimitDays)
					FS.rmSync(`${BACKUP_PATH}/${client}/backup/${date}`, {
						recursive: true,
						force: true,
					});
			});
		});
	}
}

/*
    Run all necessary processes.
*/
function runProcesses() {
	if (CONFIG.h264RtspList.length > 0) {
		CONFIG.h264RtspList.forEach((rtsp) => {
			RTSPToRTSP(rtsp, 'h264');
			if (CONVERT_LIVE_STREAM_TO_MP4) {
				RTSPToMP4(rtsp);
			}
		});
	}

	if (CONFIG.hevcRtspList.length > 0) {
		CONFIG.hevcRtspList.forEach((rtsp) => {
			RTSPToRTSP(rtsp, 'hevc');
			if (CONVERT_LIVE_STREAM_TO_MP4) {
				RTSPToMP4(rtsp);
			}
		});
	}
}

APP.use(CORS());
APP.use(EXPRESS.json());
APP.use(EXPRESS.static(__dirname));

APP.get('/forceReloadSystem', (req, res) => {
	try {
		SPAWN(`${PM2_PATH} reload mediaserver --force`, { shell: true });

		// If you enable the Frame Animation function, please uncomment the following code
		// SPAWN(`${PM2_PATH} reload rtsp-to-image --force`, { shell: true });

		res.send('success');
	} catch (err) {
		console.log(err);

		res.send(err.message);
		return;
	}
});

APP.post('/updateConfig', (req, res) => {
	const { data } = req.body;
	try {
		JSON.parse(data);

		FS.writeFile(CONFIG_PATH, data, (err) => {
			if (err) throw err;

			// Terminate all processes related to ffmpeg, media server and zombie processes.
			const killFFMPEG = SPAWN('killall -9 ffmpeg', { shell: true });
			const killZombieProcesses = SPAWN(
				`ps -Al | grep -w Z | awk '{print $4}' | xargs sudo kill -9`,
				{ shell: true }
			);

			setRtspList();
			runProcesses();

			// If you enable the Frame Animation function, please uncomment the following code
			// SPAWN(`${PM2_PATH} reload rtsp-to-image --force`, { shell: true });
		});

		res.send('success');
	} catch (err) {
		res.send(err.message);
		return;
	}
});

SERVER.listen(PORT, '0.0.0.0', () => {
	setTimeout(() => {
		setRtspList();
		runProcesses();
		if (CONVERT_LIVE_STREAM_TO_MP4) {
			setInterval(clearExpiredBackup, 1000 * 60 * 5);
		}
	}, 1000 * 10); // Buffer time reserved for reboot.
});

/*
    When the program terminates, clear the related background programs.
*/
function cleanupAndExit() {
	console.log(
		'Received exit signal. Cleaning up all running ffmpeg processes...'
	);
	const all_processes = { ...RTSP_COMMANDS, ...MP4_COMMANDS };
	const running_processes = Object.keys(all_processes);

	if (running_processes.length === 0) {
		console.log('No ffmpeg processes to kill.');
		process.exit(0);
	}

	running_processes.forEach((id) => {
		console.log(`Killing ffmpeg process for ${id}...`);
		if (RTSP_COMMANDS[id]) {
			RTSP_COMMANDS[id].kill('SIGKILL');
			delete RTSP_COMMANDS[id];
		}
		if (MP4_COMMANDS[id]) {
			MP4_COMMANDS[id].kill('SIGKILL');
			delete MP4_COMMANDS[id];
		}
	});

	// Give a moment for processes to be killed before exiting
	setTimeout(() => process.exit(0), 100);
}

process.on('SIGINT', cleanupAndExit);
process.on('SIGTERM', cleanupAndExit);

module.exports = {
	RTSPToRTSP,
};
