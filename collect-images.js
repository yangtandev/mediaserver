const { spawn: SPAWN, fork: FORK } = require('child_process');
const HTTP = require('http');
const FS = require('fs-extra');
const EXPRESS = require('express');
const CORS = require('cors');
const APP = EXPRESS();
const SERVER = HTTP.createServer(APP);
const PORT = 4000;
const PM2_Path = process.env.NVM_BIN + '/pm2';
const TIME_LAPSE_PATH = `./ZLMediaKit/release/linux/Debug/www/time-lapse`;
const CONFIG_PATH = `./ZLMediaKit/release/linux/Debug/www/config/config.json`;

let CONFIG = {};
let INTERVAL_PROCESS;

/*
    Copy the image generated by rtsp-to-image.js to the time-lapse directories.
*/
function collectImage(rtsp) {
    const ip = rtsp.split('@').pop();
    const id = ip.match(/\d+/g).join('');
    
    // Source file from rtsp-to-image.js
    const sourceImagePath = `./ZLMediaKit/release/linux/Debug/www/image/${id}.jpg`;

    // Check if source exists
    if (!FS.existsSync(sourceImagePath)) {
        console.warn(`[WARN] Source image for ${ip} (${sourceImagePath}) not found. Skipping collection.`);
        return;
    }

    const stats = FS.statSync(sourceImagePath);
    if (stats.size === 0) {
        console.warn(`[WARN] Source image for ${ip} (${sourceImagePath}) is zero bytes. Skipping collection.`);
        return;
    }

    // Destination paths from collect-images.js logic
    const now = new Date(new Date().getTime() - new Date().getTimezoneOffset() * 60000);
    const today = now.toISOString().slice(0, 10);
    const fileName = now.toISOString().slice(0, -5).split('T').join(' ');
    
    // Path for the daily backup
    const dailyBackupDir = `${TIME_LAPSE_PATH}/backup/image/${ip}/${today}`;
    const dailyBackupPath = `${dailyBackupDir}/${fileName}.jpg`;

    // Path for the collection
    const collectionDir = `${TIME_LAPSE_PATH}/backup/image/${ip}/collection`;
    const collectionPath = `${collectionDir}/${fileName}.jpg`;
    
    // Ensure directories exist
    FS.mkdirSync(dailyBackupDir, { recursive: true });
    FS.mkdirSync(collectionDir, { recursive: true });

    // Copy the file to both destinations
    FS.copyFile(sourceImagePath, dailyBackupPath, (err) => {
        if (err) {
            console.error(`[ERROR] Failed to copy image to daily backup for ${ip}:`, err);
        } else {
            console.log(`[INFO] Copied image for ${ip} to ${dailyBackupPath}`);
        }
    });

    FS.copyFile(sourceImagePath, collectionPath, (err) => {
        if (err) {
            console.error(`[ERROR] Failed to copy image to collection for ${ip}:`, err);
        } else {
            console.log(`[INFO] Copied image for ${ip} to ${collectionPath}`);
        }
    });
}

/*
    Periodically clear zero-byte files from the backup directories.
*/
function clearZeroByteFiles(rtsp) {
    const ip = rtsp.split('@').pop();
    const baseImagePath = `${TIME_LAPSE_PATH}/backup/image/${ip}`;

    const scanAndDeleteSync = (directory) => {
        if (!FS.existsSync(directory)) {
            return;
        }

        try {
            const files = FS.readdirSync(directory, { withFileTypes: true });

            for (const file of files) {
                const filePath = `${directory}/${file.name}`;
                if (file.isDirectory()) {
                    scanAndDeleteSync(filePath); // Recursive call
                } else if (file.isFile() && file.name.endsWith('.jpg')) {
                    try {
                        const stats = FS.statSync(filePath);
                        if (stats.size === 0) {
                            console.log(`[INFO] Removing zero-byte file: ${filePath}`);
                            FS.unlinkSync(filePath);
                        }
                    } catch (statErr) {
                        console.error(`[ERROR] Failed to process file ${filePath}:`, statErr);
                    }
                }
            }
        } catch (readErr) {
            console.error(`[ERROR] Failed to read directory ${directory}:`, readErr);
        }
    };

    scanAndDeleteSync(baseImagePath);
}



/*
    Periodically clear backups that are one month overdue.
*/
function clearExpiredBackup(rtsp) {
	const ip = rtsp.split('@').pop();
	const today = new Date().toISOString().slice(0, 10);

	FS.readdir(`${TIME_LAPSE_PATH}/backup/image/${ip}`, (err, dateList) => {
		dateList = dateList.filter((date) => date !== 'collection');
		dateList.forEach((date) => {
			const diffTime = Math.abs(new Date(today) - new Date(date));
			const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

			if (diffDays >= CONFIG.retentionDays) {
				FS.rmdirSync(`${TIME_LAPSE_PATH}/backup/image/${ip}/${date}`, {
					recursive: true,
					force: true,
				});
			}
		});
	});
}

/*
    Set rtsp list related variables.
*/
function setRtspList() {
	const source = JSON.parse(FS.readFileSync(CONFIG_PATH, 'utf8'));
	CONFIG = JSON.parse(JSON.stringify(source));

	if (CONFIG.timelapseClientList.length > 0) {
		CONFIG.allRtspList = CONFIG.timelapseClientList
			.map((clinet) => clinet.rtspList)
			.reduce((prev, curr) => prev.concat(curr));
	} else {
		CONFIG.allRtspList = [];
	}
}

function getInterval() {
	return setInterval(
		(function runProcesses() {
			setRtspList();

			if (CONFIG.allRtspList.length > 0) {
				CONFIG.allRtspList.forEach((rtsp) => {
					collectImage(rtsp);
				});
			}

			// If you need to automatically clear the backup, please uncomment the following code.
			// if (CONFIG.allRtspList.length > 0) {
			// 	CONFIG.allRtspList.forEach((rtsp) => {
			// 		clearExpiredBackup(rtsp);
			// 	});
			// }

			return runProcesses;
		})(),
		1000 * CONFIG.screenshotFrequencyInSeconds
	);
}

APP.use(CORS());
APP.use(EXPRESS.json());
APP.use(EXPRESS.static(__dirname));

APP.get('/generateTimeLapse', (req, res) => {
	try {
		FORK('./generate-time-lapse.js');

		res.send('success');
	} catch (err) {
		res.send(err.message);
		return;
	}
});

APP.get('/forceReloadSystem', (req, res) => {
	try {
		// Force reload main process.
		SPAWN(`${PM2_Path} reload mediaserver --force`, { shell: true });

		res.send('success');
	} catch (err) {
		res.send(err.message);
		return;
	}
});

APP.post('/updateConfig', (req, res) => {
	const { data } = req.body;
	try {
		JSON.parse(data);

		FS.writeFile(CONFIG_PATH, data, (err) => {
			if (err) throw err;

			setRtspList();
			clearInterval(INTERVAL_PROCESS);
			INTERVAL_PROCESS = getInterval();
		});

		res.send('success');
	} catch (err) {
		res.send(err.message);
		return;
	}
});

/*
    Run all necessary processes.
*/
SERVER.listen(PORT, () => {
	console.log(`http://localhost:9080/time-lapse/backup/video`);

	INTERVAL_PROCESS = getInterval();

    // Set up a less frequent interval for cleanup tasks
    setInterval(() => {
        setRtspList(); // Ensure we have the latest list
        if (CONFIG.allRtspList && CONFIG.allRtspList.length > 0) {
            console.log('[INFO] Running periodic cleanup of zero-byte files...');
            CONFIG.allRtspList.forEach(rtsp => {
                clearZeroByteFiles(rtsp);
            });
        }
    }, 3600000); // Run once per hour
});

function cleanupAndExit() {
	console.log(
		'Received exit signal. Gracefully cleaning up all running processes...'
	);
	// IMAGE_COMMANDS is no longer relevant as collect-images.js doesn't manage ffmpeg processes directly.
	// We only need to clear the interval and exit.
	if (INTERVAL_PROCESS) {
		clearInterval(INTERVAL_PROCESS);
	}
	process.exit(0);
}

process.on('SIGINT', cleanupAndExit);
process.on('SIGTERM', cleanupAndExit);


