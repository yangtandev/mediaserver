<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>CCTV</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}
			body {
				display: grid;
				grid-template-columns: repeat(5, 1fr);
				grid-template-rows: repeat(3, 1fr);
				width: 100vw;
				height: 100vh;
				background-color: #000;
				overflow: hidden;
				gap: 0;
			}
			canvas {
				/* Display size via CSS, internal resolution handled by attributes */
				width: 100%;
				height: 100%;
				transform: translateZ(0);
				backface-visibility: hidden;
			}
		</style>
	</head>
	<body>
		<script>
			const canvases = [];
			const dpr = window.devicePixelRatio || 1;
			const ips = ['11816349728081', '11816349728082'];

			// Create canvas elements for each device and adjust for DPR
			for (let i = 1; i <= ips.length; i++) {
				const canvas = document.createElement('canvas');
				const cssWidth = window.innerWidth / 5;
				const cssHeight = window.innerHeight / 3;

				// Set internal resolution based on device pixel ratio
				canvas.width = cssWidth * dpr;
				canvas.height = cssHeight * dpr;
				canvas.style.width = cssWidth + 'px';
				canvas.style.height = cssHeight + 'px';

				document.body.appendChild(canvas);
				canvases.push({ canvas, index: i });
			}

			// Render image on canvas using offscreen buffer to prevent flickering
			function updateCanvasImage(canvasObj) {
				const canvas = canvasObj.canvas;
				const ctx = canvas.getContext('2d');

				// Enable high-quality scaling
				ctx.imageSmoothingEnabled = true;
				ctx.imageSmoothingQuality = 'high';

				// Create offscreen canvas for double buffering
				const offscreen = document.createElement('canvas');
				offscreen.width = canvas.width;
				offscreen.height = canvas.height;
				const offCtx = offscreen.getContext('2d');
				offCtx.imageSmoothingEnabled = true;
				offCtx.imageSmoothingQuality = 'high';

				function loadAndDraw() {
					const timestamp = new Date().getTime();
					const ip = ips[canvasObj.index - 1];
					const imgUrl = `http://localhost:9080/image/${ip}.jpg?t=${timestamp}`;
					const img = new Image();
					img.crossOrigin = 'anonymous';

					img.onload = function () {
						offCtx.clearRect(0, 0, offscreen.width, offscreen.height);

						// Calculate "contain" mode scaling and centering
						const iw = img.width, ih = img.height;
						const cw = offscreen.width, ch = offscreen.height;
						const scale = Math.min(cw / iw, ch / ih);
						const nw = iw * scale, nh = ih * scale;
						const dx = (cw - nw) / 2, dy = (ch - nh) / 2;

						offCtx.drawImage(img, 0, 0, iw, ih, dx, dy, nw, nh);

						requestAnimationFrame(() => {
							ctx.clearRect(0, 0, canvas.width, canvas.height);
							ctx.drawImage(offscreen, 0, 0);
						});

						setTimeout(loadAndDraw, 200);
					};

					img.onerror = function () {
						console.warn(`Failed to load image: ${imgUrl}`);
						setTimeout(loadAndDraw, 1000);
					};

					img.src = imgUrl;
				}

				loadAndDraw();
			}

			// Start rendering loop for each canvas
			canvases.forEach((item) => {
				updateCanvasImage(item);
			});
		</script>
	</body>
</html>
